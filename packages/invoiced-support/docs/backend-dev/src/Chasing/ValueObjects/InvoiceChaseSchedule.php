<?php

namespace App\Chasing\ValueObjects;

use Iterator;
use OutOfBoundsException;

/**
 * Immutable representation of an invoice chasing schedule.
 */
class InvoiceChaseSchedule implements Iterator
{
    private int $index;

    /**
     * @param InvoiceChaseStep[] $schedule
     */
    public function __construct(private array $schedule)
    {
        $this->index = 0;
    }

    public function current(): InvoiceChaseStep
    {
        return $this->schedule[$this->index]->copy();
    }

    public function next(): void
    {
        ++$this->index;
    }

    public function key(): int
    {
        return $this->index;
    }

    public function valid(): bool
    {
        return isset($this->schedule[$this->index]);
    }

    public function rewind(): void
    {
        $this->index = 0;
    }

    public function size(): int
    {
        return count($this->schedule);
    }

    /**
     * @throws OutOfBoundsException
     */
    public function get(int $index): InvoiceChaseStep
    {
        if (isset($this->schedule[$index])) {
            return $this->schedule[$index]->copy();
        }

        throw new OutOfBoundsException("Index value $index is out of bounds");
    }

    /**
     * Returns a map of step id -> step value.
     *
     * NOTE: Value at key 'null' is unpredictable if there exists
     * more than one step w/ a null id.
     *
     * @return InvoiceChaseStep[]
     */
    public function map(): array
    {
        $map = [];
        foreach ($this->schedule as $step) {
            $map[$step->getId()] = $step->copy();
        }

        return $map;
    }

    /**
     * Returns a HashMap represented as an associative array such that
     * the associative array keys are hashes of the steps generated by
     * the InvoiceChaseStep::hash() function.
     *
     * @return InvoiceChaseStep[]
     */
    public function hashMap(): array
    {
        $map = [];
        foreach ($this->schedule as $step) {
            $map[$step->hash()] = $step->copy();
        }

        return $map;
    }

    /**
     * Merges ids of chase schedule steps that belong to
     * the intersection of both chase schedules.
     *
     * @return $this
     */
    public function intersect(self $chaseSchedule): self
    {
        $mergingHashMap = $chaseSchedule->hashMap();
        foreach ($this->schedule as $step) {
            if ($mergeStep = $mergingHashMap[$step->hash()] ?? null) {
                $step->setId($mergeStep->getId());
            }
        }

        return $this;
    }

    /**
     * Determines if the chase schedule is equal to the one provided.
     *
     * @param bool $strict whether or not to compare step ids
     */
    public function equals(InvoiceChaseSchedule $schedule, bool $strict = false): bool
    {
        $a = $this->toArray();
        $b = $schedule->toArray();
        if (count($a) != count($b)) {
            return false;
        }

        foreach ($a as $i => $aStep) {
            $bStep = $b[$i];
            if (!$aStep->equals($bStep, $strict)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Returns an array of steps in array format.
     */
    public function toArrays(): array
    {
        $_schedule = [];
        foreach ($this->schedule as $step) {
            $_schedule[] = $step->toArray();
        }

        return $_schedule;
    }

    /**
     * @return InvoiceChaseStep[]
     */
    public function toArray(): array
    {
        $_schedule = [];
        foreach ($this->schedule as $step) {
            $_schedule[] = $step;
        }

        return $_schedule;
    }

    public static function fromArrays(array $schedule): InvoiceChaseSchedule
    {
        /** @var InvoiceChaseStep[] $_schedule */
        $_schedule = [];
        foreach ($schedule as $step) {
            $_schedule[] = new InvoiceChaseStep($step['trigger'] ?? 0, $step['options'] ?? [], $step['id'] ?? null);
        }

        return new InvoiceChaseSchedule($_schedule);
    }
}
