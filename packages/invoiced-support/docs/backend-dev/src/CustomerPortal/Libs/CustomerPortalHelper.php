<?php

namespace App\CustomerPortal\Libs;

use App\AccountsReceivable\Models\Customer;
use App\Companies\Models\Company;
use App\Metadata\Interfaces\MetadataModelInterface;
use App\Metadata\Libs\CustomFieldRepository;
use App\Metadata\Libs\MetadataFormatter;
use App\PaymentProcessing\Models\Card;
use App\PaymentProcessing\Models\PaymentSource;

class CustomerPortalHelper
{
    private const CARD_BRANDS = [
        '2checkout',
        'american-express',
        'cirrus',
        'delta',
        'direct-debit',
        'discover',
        'ebay',
        'google-checkout',
        'maestro',
        'mastercard',
        'moneybookers',
        'paypal',
        'sagepay',
        'solo',
        'visa',
        'visa-electron',
        'western-union',
    ];

    /**
     * Gets object custom fields formatted for use in the customer portal.
     */
    public static function getCustomFields(Company $company, Customer $customer, string $objectType, MetadataModelInterface $model): array
    {
        $customFields = CustomFieldRepository::get($company)->getFieldsForObject($objectType, true);
        $metadataFormatter = new MetadataFormatter($company, $customer, true);

        $inheritFromCustomer = null;
        if (method_exists($model, 'customer')) {
            $inheritFromCustomer = $model->customer();
        }

        $customFieldValues = [];
        foreach ($customFields as $field) {
            $k = $field->id;

            // First get value from the model
            if (property_exists($model->metadata, $k)) {
                $customFieldValues[] = [
                    'id' => $field->id,
                    'name' => $field->name,
                    'value' => $metadataFormatter->format($field, $model->metadata->$k),
                ];

                continue;
            }

            // Fallback to value from the customer, if there is one
            if ($inheritFromCustomer) {
                if (property_exists($inheritFromCustomer->metadata, $k)) {
                    $customFieldValues[] = [
                        'id' => $field->id,
                        'name' => $field->name,
                        'value' => $metadataFormatter->format($field, $inheritFromCustomer->metadata->$k),
                    ];
                }
            }
        }

        return $customFieldValues;
    }

    public static function getPaymentSourceIcon(PaymentSource $paymentSource): string
    {
        if ($paymentSource instanceof Card) {
            $brand = str_replace(' ', '-', strtolower($paymentSource->brand));
            if (!in_array($brand, self::CARD_BRANDS)) {
                return '/img/payment-icons/credit_card.png';
            }

            return '/img/payment-icons/'.$brand.'-curved-64px.png';
        }

        return '/img/payment-icons/bank_account.png';
    }

    public static function addQueryParametersToUrl(string $url, array $parameters): string
    {
        // Rebuilds a URL from the components generated by parse_url().
        // Found on http://php.net/parse_url
        $parsed = (array) parse_url($url);

        // Combine the added query parameters with the original parameters
        parse_str($parsed['query'] ?? '', $query);
        $query = array_merge($query, $parameters);

        // Build a new URL
        $scheme = isset($parsed['scheme']) ? $parsed['scheme'].'://' : '';
        $host = $parsed['host'] ?? '';
        $port = isset($parsed['port']) ? ':'.$parsed['port'] : '';
        $user = $parsed['user'] ?? '';
        $pass = isset($parsed['pass']) ? ':'.$parsed['pass'] : '';
        $pass = ($user || $pass) ? "$pass@" : '';
        $path = $parsed['path'] ?? '';
        $query = $query ? '?'.http_build_query($query) : '';
        $fragment = isset($parsed['fragment']) ? '#'.$parsed['fragment'] : '';

        return "$scheme$user$pass$host$port$path$query$fragment";
    }
}
