<?php

namespace App\Integrations\NetSuite\Libs;

use NetSuite\NetSuiteService;
use Psr\Log\LoggerAwareTrait;
use SimpleXMLElement;
use SoapClient;

/**
 * This adds retry logic to the NetSuite API client
 * with exponential backoff and logging.
 * The retry logic helps deal with intermittent errors
 * we may encounter.
 */
class NetSuiteRetryClient extends NetSuiteService
{
    use LoggerAwareTrait;

    private const MAX_RETRIES = 3;

    private SoapClient $client;
    private int $retries = 0;

    public function __construct($config, private string $projectDir, $options = [], $client = null)
    {
        if (!$client) {
            // We have to create our own SOAP client here
            // because it is needed for logging and the client
            // generated by the parent constructor is private.
            $options = $this->createOptions($config, $options);
            $wsdl = $this->createWsdl($config);
            $client = new SoapClient($wsdl, $options);
        }

        $this->client = $client;
        parent::__construct($config, $options, $client);
    }

    /**
     * Create the options array.
     */
    private function createOptions(array $config, array $overrides = []): array
    {
        return array_merge([
            'classmap' => require $this->projectDir.'/vendor/ryanwinchester/netsuite-php/src/includes/classmap.php',
            'trace' => 1,
            'connection_timeout' => 5,
            'cache_wsdl' => WSDL_CACHE_BOTH,
            'location' => $config['host'].'/services/NetSuitePort_'.$config['endpoint'],
            'keep_alive' => false,
            'features' => SOAP_SINGLE_ELEMENT_ARRAYS,
            'user_agent' => 'PHP-SOAP/'.phpversion().' + ryanwinchester/netsuite-php',
        ], $overrides);
    }

    /**
     * Build the WSDL address from the config.
     */
    private function createWsdl(array $config): string
    {
        return $config['host'].'/wsdl/v'.$config['endpoint'].'_0/netsuite.wsdl';
    }

    protected function makeSoapCall($operation, $parameter)
    {
        try {
            $result = parent::makeSoapCall($operation, $parameter);
            $this->logSoapCall($this->client);
        } catch (\SoapFault $e) {
            // Sometimes we get this error where it's not clear
            // what went wrong so we can retry the request and
            // the next one will likely succeed.
            if ('HTTP' == $e->faultcode && 'Error Fetching http headers' == $e->faultstring) {
                // retry with exponential backoff
                if ($this->retries < self::MAX_RETRIES) {
                    ++$this->retries;
                    // Sleep 2 ^ N * 2 seconds
                    sleep(2 ** $this->retries * 2);

                    return $this->makeSoapCall($operation, $parameter);
                }
            }

            $this->retries = 0;

            $this->logSoapCall($this->client);

            throw $e;
        }

        $this->retries = 0;

        return $result;
    }

    /**
     * Log the last soap call as request and response XML files.
     */
    private function logSoapCall(SoapClient $client): void
    {
        if (!isset($this->logger)) {
            return;
        }

        // log the request
        $requestXml = (string) $client->__getLastRequest();
        $requestXml = cleanUpNamespaces($requestXml);

        /** @var SimpleXMLElement $xml */
        $xml = simplexml_load_string($requestXml, 'SimpleXMLElement', LIBXML_NOCDATA);

        // scrub sensitive data from the request
        $privateFieldXpaths = [
            '//password',
            '//password2',
            '//currentPassword',
            '//newPassword',
            '//newPassword2',
            '//ccNumber',
            '//ccSecurityCode',
            '//socialSecurityNumber',
        ];

        $privateFields = $xml->xpath(implode(' | ', $privateFieldXpaths));

        foreach ($privateFields as &$field) {
            $field[0] = '[Content Removed for Security Reasons]'; /* @phpstan-ignore-line */
        }

        $stringCustomFields = $xml->xpath("//customField[@xsitype='StringCustomFieldRef']");

        foreach ($stringCustomFields as $field) {
            $field->value = '[Content Removed for Security Reasons]';
        }

        $logEntry = ">>>>>>>>\n";
        $logEntry .= $client->__getLastRequestHeaders()."\n";
        $logEntry .= str_replace('xsitype', 'xsi:type', (string) $xml->asXML());

        // log the response
        $logEntry .= "<<<<<<<<\n";
        $logEntry .= $client->__getLastResponseHeaders()."\n";
        $logEntry .= $client->__getLastResponse();

        $this->logger->debug($logEntry);
    }
}
